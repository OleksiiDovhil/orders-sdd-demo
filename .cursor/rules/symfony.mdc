---
description: Symfony Framework Best Practices and Guidelines
globs: ["src/Presentation/**/*.php", "config/**/*.yaml", "src/Infrastructure/**/*.php"]
---

# Symfony Best Practices

## Controllers

### Thin Controllers
- Keep controllers thin - delegate to application services
- Controllers should only handle HTTP concerns (request/response)
- Business logic belongs in Application layer

### Controller Best Practices
- **Accept Request DTOs as parameters** - Use ValueResolver for automatic deserialization and validation
- **No manual JSON parsing** - Let ValueResolver handle request transformation
- **No manual validation** - Validation happens automatically via Symfony Validator
- **Request DTOs convert to Commands** - Use `createCommand()` or similar methods in request DTOs
- **Exception listeners handle errors** - Use global exception listeners for consistent error responses
- **Keep controllers thin** - Only orchestrate HTTP concerns, delegate to handlers

### Controller Example
```php
<?php

declare(strict_types=1);

namespace App\Presentation\Controller\User;

use App\Application\User\Command\CreateUserHandler;
use App\Presentation\Request\CreateUserRequest;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

final class CreateUserController extends AbstractController
{
    public function __construct(
        private readonly CreateUserHandler $handler
    ) {
    }

    #[Route('/api/users', name: 'api_users_create', methods: ['POST'])]
    public function __invoke(CreateUserRequest $request): JsonResponse
    {
        // Request is automatically deserialized and validated by ValueResolver
        $command = $request->createCommand();
        
        $user = $this->handler->handle($command);
        
        return new JsonResponse(
            [
                'id' => $user->getId()->getValue(),
                'email' => $user->getEmail()->getValue(),
                'name' => $user->getName(),
            ],
            Response::HTTP_CREATED
        );
    }
}
```

### Request DTO Example
```php
<?php

declare(strict_types=1);

namespace App\Presentation\Request;

use App\Application\User\Command\CreateUserCommand;
use Symfony\Component\Validator\Constraints as Assert;

final readonly class CreateUserRequest
{
    public function __construct(
        #[Assert\NotBlank(message: 'Email is required')]
        #[Assert\Email(message: 'Email must be valid')]
        public string $email,

        #[Assert\NotBlank(message: 'Name is required')]
        #[Assert\Length(min: 2, max: 100, minMessage: 'Name must be at least 2 characters')]
        public string $name
    ) {
    }

    public function createCommand(): CreateUserCommand
    {
        return new CreateUserCommand(
            $this->email,
            $this->name
        );
    }
}
```

### HTTP Status Codes
- Use appropriate HTTP status codes
- 200: Success (GET, PUT, PATCH)
- 201: Created (POST)
- 204: No Content (DELETE)
- 400: Bad Request (validation errors)
- 404: Not Found
- 500: Internal Server Error

## Services

### Service Registration
- Register services in `config/services.yaml`
- Use autowiring and autoconfiguration
- Tag services appropriately

### Service Configuration Example
```yaml
# config/services.yaml
services:
    _defaults:
        autowire: true
        autoconfigure: true

    App\:
        resource: '../src/'
        exclude:
            - '../src/DependencyInjection/'
            - '../src/Entity/'
            - '../src/Kernel.php'

    # Interface to implementation mapping
    App\Domain\User\Repository\UserRepositoryInterface:
        alias: App\Infrastructure\Persistence\UserRepository

    # Event listeners
    App\Infrastructure\Event\UserCreatedListener:
        tags:
            - { name: kernel.event_listener, event: user.created }
```

### Service Naming
- Use FQCN (Fully Qualified Class Name) for service IDs
- Symfony will auto-generate service IDs from class names
- Use aliases for interfaces

## Configuration

### YAML Configuration
- Use YAML for configuration files
- Keep environment-specific config in `.env` files
- Use Symfony's parameter system for config values

### Environment Variables
```bash
# .env
DATABASE_URL=mysql://user:password@127.0.0.1:3306/dbname
APP_ENV=dev
APP_SECRET=your-secret-key
```

### Parameter Configuration
```yaml
# config/services.yaml
parameters:
    app.max_users_per_page: 50
    app.email.from: 'noreply@example.com'
```

## Routing

### Attribute Routing (Preferred)
```php
#[Route('/api/users/{id}', name: 'api_users_get', methods: ['GET'])]
public function getUser(string $id): JsonResponse
{
    // ...
}
```

### YAML Routing
```yaml
# config/routes.yaml
api_users_get:
    path: /api/users/{id}
    controller: App\Presentation\Controller\User\GetUserController
    methods: [GET]
```

## Dependency Injection

### Constructor Injection (Preferred)
```php
public function __construct(
    private readonly UserRepositoryInterface $userRepository,
    private readonly EventDispatcherInterface $eventDispatcher
) {
}
```

### Property Injection (Avoid)
- Only use when necessary (e.g., circular dependencies)
- Prefer constructor injection

## Events

### Domain Events
- Use Symfony EventDispatcher for domain events
- Define event classes in Domain layer
- Listeners in Infrastructure layer

### Event Example
```php
<?php

declare(strict_types=1);

namespace App\Domain\User\Event;

use App\Domain\User\ValueObject\UserId;

final class UserCreatedEvent
{
    public function __construct(
        public readonly UserId $userId,
        public readonly string $email
    ) {
    }
}
```

### Event Listener
```php
<?php

declare(strict_types=1);

namespace App\Infrastructure\Event;

use App\Domain\User\Event\UserCreatedEvent;
use Symfony\Component\EventDispatcher\Attribute\AsEventListener;

#[AsEventListener(event: UserCreatedEvent::class)]
final class UserCreatedListener
{
    public function __invoke(UserCreatedEvent $event): void
    {
        // Handle event (e.g., send welcome email)
    }
}
```

## Request DTOs and Validation

### Request DTO Location
- Create request DTOs in `src/Presentation/Request/`
- Use `readonly` classes with constructor properties
- Use Symfony Validation attributes for declarative validation

### Request DTO Requirements
- **Must have `createCommand()` method** - Convert request DTO to application command
- **Use Validation attributes** - `#[Assert\NotBlank]`, `#[Assert\Type]`, `#[Assert\Choice]`, etc.
- **Type safety** - Use proper type hints for all properties
- **Immutable** - Use `readonly` class to prevent modification
- **OpenAPI Documentation** - Add `OA\Schema` and `OA\Property` attributes to request DTOs for API documentation

### OpenAPI Documentation
- **MANDATORY: Add OpenAPI documentation to both Controller and Request classes**
- **Request classes**: Add `OA\Schema` attribute to the class and `OA\Property` attributes to each property
- **Controller classes**: Add `OA\Get`, `OA\Post`, etc. attributes with endpoint documentation
- **Request body schemas**: Reference request schemas from Request classes using `ref: '#/components/schemas/SchemaName'`
- **OpenAPI generator**: The generator scans both `src/Presentation/Controller` and `src/Presentation/Request` directories
- **Schema definitions**: Define schemas in Request classes, not in separate Schema classes
- **Example**: For request bodies, use `new OA\JsonContent(ref: '#/components/schemas/CreateOrderRequest')` in controller, and define the schema in the Request class with `#[OA\Schema(schema: 'CreateOrderRequest', ...)]`

### Automatic Request Injection
- Use `RequestValueResolver` for automatic deserialization and validation
- Register in `config/services.yaml` with `controller.argument_value_resolver` tag
- Request DTOs are automatically injected as controller parameters
- Validation happens before controller is called

### Validation Example
```php
<?php

declare(strict_types=1);

namespace App\Presentation\Request;

use App\Application\Order\Command\CreateOrderCommand;
use Symfony\Component\Validator\Constraints as Assert;

final readonly class CreateOrderRequest
{
    public function __construct(
        #[Assert\NotBlank(message: 'Sum is required')]
        #[Assert\Type(type: 'integer', message: 'Sum must be an integer')]
        #[Assert\GreaterThanOrEqual(value: 0, message: 'Sum must be non-negative')]
        public int $sum,

        #[Assert\NotBlank(message: 'Contractor type is required')]
        #[Assert\Choice(choices: [1, 2], message: 'Contractor type must be 1 or 2')]
        public int $contractorType
    ) {
    }

    public function createCommand(): CreateOrderCommand
    {
        return new CreateOrderCommand(
            $this->sum,
            $this->contractorType
        );
    }
}
```

## Error Handling

### Exception Handling
- Use custom domain exceptions
- Create exception listeners for global error handling
- Return appropriate HTTP status codes
- **Always handle ValidationFailedException** - Convert to structured error responses
- **Handle InvalidArgumentException** - Convert domain validation errors to HTTP responses

### Exception Listener Example
```php
<?php

declare(strict_types=1);

namespace App\Infrastructure\Event;

use Symfony\Component\EventDispatcher\Attribute\AsEventListener;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\ExceptionEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\Validator\Exception\ValidationFailedException;

#[AsEventListener(event: KernelEvents::EXCEPTION, priority: 10)]
final class ValidationExceptionListener
{
    public function onKernelException(ExceptionEvent $event): void
    {
        $exception = $event->getThrowable();

        if ($exception instanceof ValidationFailedException) {
            $errors = [];
            foreach ($exception->getViolations() as $violation) {
                $propertyPath = $violation->getPropertyPath();
                $errors[$propertyPath] = $violation->getMessage();
            }

            $response = new JsonResponse(
                ['errors' => $errors],
                JsonResponse::HTTP_BAD_REQUEST
            );

            $event->setResponse($response);
            return;
        }

        if ($exception instanceof \InvalidArgumentException) {
            $response = new JsonResponse(
                ['error' => $exception->getMessage()],
                JsonResponse::HTTP_BAD_REQUEST
            );

            $event->setResponse($response);
        }
    }
}
```

## Security

### Input Validation
- Validate and sanitize all user input at boundaries
- Use type hints and strict types
- Never trust user input

### Authentication & Authorization
- Use Symfony Security component
- Implement proper authentication mechanisms
- Use voters for complex authorization logic

## Performance

### Caching
- Use Symfony Cache component
- Cache expensive operations
- Use appropriate cache adapters

### Database Queries
- Use Doctrine Query Builder for complex queries
- Avoid N+1 query problems
- Use eager loading when appropriate

## Development Workflow

### After Code Changes
1. **Always run tests** - Execute `make test` after any code changes
2. **Fix failing tests** - Never leave tests in a failing state
3. **Verify all tests pass** - Only consider work complete when all tests pass
4. **Tests are a quality gate** - Code with failing tests is incomplete

### Test Commands
```bash
# Run all tests (MANDATORY after code changes)
make test

# Run specific test suites
make test-unit
make test-feature

# Run with coverage
make test-coverage

# Run specific test file
make test-file FILE=tests/Feature/Order/CreateOrderTest.php

# Run with filter
make test-filter FILTER=CreateOrderRequest
```

## Best Practices Summary

1. **Thin Controllers**: Delegate to application services
2. **Service Autowiring**: Use constructor injection
3. **Configuration**: Use YAML and environment variables
4. **Routing**: Prefer attribute routing
5. **Events**: Use domain events for decoupling
6. **Validation**: Validate at boundaries
7. **Error Handling**: Use custom exceptions and listeners
8. **Security**: Validate all input, use security component
9. **Performance**: Cache appropriately, optimize queries
10. **Testing**: Always run tests after changes, fix failures immediately
