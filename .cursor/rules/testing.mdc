---
description: Unit and Feature Testing Guidelines
globs: ["tests/**/*.php"]
---

# Testing Guidelines

## Test Structure

### Directory Organization
Mirror `src/` structure in `tests/`:
```
tests/
├── Unit/
│   └── Domain/
│       └── {BoundedContext}/
│           ├── Entity/
│           ├── ValueObject/
│           └── Service/
├── Feature/
│   └── {BoundedContext}/
│       └── {UseCase}Test.php
└── Integration/
    └── Infrastructure/
```

## Test Types

### Unit Tests
- Test individual classes in isolation
- Focus on Domain layer (entities, value objects, domain services)
- Mock all external dependencies
- Fast execution
- High code coverage target

### Feature Tests
- Test complete use cases end-to-end
- Test Application layer (commands, queries, services)
- May use real implementations or test doubles
- Verify business logic flows

### Integration Tests
- Test Infrastructure layer
- Test interactions with external systems (database, APIs)
- Use test database or mocks for external services

## Testing Best Practices

### AAA Pattern
Follow Arrange, Act, Assert pattern:

```php
public function testShouldCreateValidEmail(): void
{
    // Arrange
    $emailValue = 'user@example.com';
    
    // Act
    $email = new Email($emailValue);
    
    // Assert
    $this->assertSame($emailValue, $email->getValue());
}
```

### Test Naming
- Use descriptive test method names
- Format: `testShould{ExpectedBehavior}When{Condition}()`
- Examples:
  - `testShouldThrowExceptionWhenEmailIsInvalid()`
  - `testShouldReturnUserWhenIdExists()`
  - `testShouldReturnNullWhenUserNotFound()`

### Test Organization
- One test class per class under test
- Group related tests using `@group` annotation
- Use data providers for testing multiple scenarios

## Unit Test Examples

### Value Object Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\User\ValueObject;

use App\Domain\User\ValueObject\Email;
use PHPUnit\Framework\TestCase;

final class EmailTest extends TestCase
{
    public function testShouldCreateValidEmail(): void
    {
        $email = new Email('user@example.com');
        
        $this->assertSame('user@example.com', $email->getValue());
    }

    public function testShouldThrowExceptionWhenEmailIsInvalid(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('Invalid email address');
        
        new Email('invalid-email');
    }

    public function testShouldReturnTrueWhenEmailsAreEqual(): void
    {
        $email1 = new Email('user@example.com');
        $email2 = new Email('user@example.com');
        
        $this->assertTrue($email1->equals($email2));
    }

    public function testShouldReturnFalseWhenEmailsAreDifferent(): void
    {
        $email1 = new Email('user1@example.com');
        $email2 = new Email('user2@example.com');
        
        $this->assertFalse($email1->equals($email2));
    }
}
```

### Entity Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\User\Entity;

use App\Domain\User\Entity\User;
use App\Domain\User\ValueObject\Email;
use App\Domain\User\ValueObject\UserId;
use PHPUnit\Framework\TestCase;

final class UserTest extends TestCase
{
    public function testShouldCreateUser(): void
    {
        $userId = UserId::generate();
        $email = new Email('user@example.com');
        $name = 'John Doe';
        
        $user = new User($userId, $email, $name);
        
        $this->assertSame($userId, $user->getId());
        $this->assertSame($email, $user->getEmail());
        $this->assertSame($name, $user->getName());
    }

    public function testShouldChangeName(): void
    {
        $user = $this->createUser();
        $newName = 'Jane Doe';
        
        $user->changeName($newName);
        
        $this->assertSame($newName, $user->getName());
    }

    private function createUser(): User
    {
        return new User(
            UserId::generate(),
            new Email('user@example.com'),
            'John Doe'
        );
    }
}
```

### Domain Service Test with Mocking
```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\User\Service;

use App\Domain\User\Entity\User;
use App\Domain\User\Repository\UserRepositoryInterface;
use App\Domain\User\Service\UserService;
use App\Domain\User\ValueObject\Email;
use App\Domain\User\ValueObject\UserId;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;

final class UserServiceTest extends TestCase
{
    private UserRepositoryInterface&MockObject $repository;
    private UserService $service;

    protected function setUp(): void
    {
        $this->repository = $this->createMock(UserRepositoryInterface::class);
        $this->service = new UserService($this->repository);
    }

    public function testShouldCreateUser(): void
    {
        $email = new Email('user@example.com');
        $name = 'John Doe';
        
        $this->repository
            ->expects($this->once())
            ->method('save')
            ->with($this->callback(function (User $user) use ($email, $name) {
                return $user->getEmail()->equals($email) 
                    && $user->getName() === $name;
            }));
        
        $user = $this->service->createUser($email, $name);
        
        $this->assertInstanceOf(User::class, $user);
    }
}
```

## Feature Test Examples

### Application Service Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Feature\User;

use App\Application\User\Command\CreateUserCommand;
use App\Application\User\Command\CreateUserHandler;
use App\Domain\User\Repository\UserRepositoryInterface;
use PHPUnit\Framework\TestCase;

final class CreateUserTest extends TestCase
{
    private UserRepositoryInterface $repository;
    private CreateUserHandler $handler;

    protected function setUp(): void
    {
        // Use real repository or in-memory implementation
        $this->repository = new InMemoryUserRepository();
        $this->handler = new CreateUserHandler($this->repository);
    }

    public function testShouldCreateUserSuccessfully(): void
    {
        $command = new CreateUserCommand(
            'user@example.com',
            'John Doe'
        );
        
        $user = $this->handler->handle($command);
        
        $this->assertNotNull($user);
        $this->assertSame('user@example.com', $user->getEmail()->getValue());
        $this->assertSame('John Doe', $user->getName());
        
        $savedUser = $this->repository->findById($user->getId());
        $this->assertNotNull($savedUser);
    }
}
```

### HTTP Endpoint Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Feature\User;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

final class CreateUserEndpointTest extends WebTestCase
{
    public function testShouldCreateUserViaApi(): void
    {
        $client = static::createClient();
        
        $client->request(
            'POST',
            '/api/users',
            [],
            [],
            ['CONTENT_TYPE' => 'application/json'],
            json_encode([
                'email' => 'user@example.com',
                'name' => 'John Doe',
            ])
        );
        
        $this->assertResponseStatusCodeSame(201);
        $this->assertJson($client->getResponse()->getContent());
        
        $response = json_decode($client->getResponse()->getContent(), true);
        $this->assertArrayHasKey('id', $response);
        $this->assertSame('user@example.com', $response['email']);
    }

    public function testShouldReturn400WhenEmailIsInvalid(): void
    {
        $client = static::createClient();
        
        $client->request(
            'POST',
            '/api/users',
            [],
            [],
            ['CONTENT_TYPE' => 'application/json'],
            json_encode([
                'email' => 'invalid-email',
                'name' => 'John Doe',
            ])
        );
        
        $this->assertResponseStatusCodeSame(400);
        $response = json_decode($client->getResponse()->getContent(), true);
        $this->assertArrayHasKey('errors', $response);
        $this->assertArrayHasKey('email', $response['errors']);
    }
}
```

## Request DTO Testing

### Unit Tests for Request DTOs
**CRITICAL**: Always create unit tests for request DTOs, especially for `createCommand()` methods.

```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Presentation\Request;

use App\Application\Order\Command\CreateOrderCommand;
use App\Presentation\Request\CreateOrderRequest;
use PHPUnit\Framework\TestCase;

final class CreateOrderRequestTest extends TestCase
{
    public function testShouldCreateCommandFromRequest(): void
    {
        // Arrange
        $request = new CreateOrderRequest(
            sum: 1000,
            contractorType: 1,
            items: []
        );

        // Act
        $command = $request->createCommand();

        // Assert
        $this->assertInstanceOf(CreateOrderCommand::class, $command);
        $this->assertEquals(1000, $command->sum);
        $this->assertEquals(1, $command->contractorType);
    }
}
```

### Feature Tests for Validation
**CRITICAL**: Always test all validation scenarios in feature tests.

```php
public function testShouldReturnBadRequestWhenRequiredFieldsAreMissing(): void
{
    $client = static::createClient();
    $requestData = ['sum' => 1000]; // Missing required fields

    $client->request('POST', '/api/orders', [], [], [
        'CONTENT_TYPE' => 'application/json',
    ], json_encode($requestData));

    $this->assertResponseStatusCodeSame(400);
    $response = json_decode($client->getResponse()->getContent(), true);
    $this->assertArrayHasKey('errors', $response);
    $this->assertArrayHasKey('contractorType', $response['errors']);
}

public function testShouldReturnBadRequestWhenInvalidJsonFormat(): void
{
    $client = static::createClient();

    $client->request('POST', '/api/orders', [], [], [
        'CONTENT_TYPE' => 'application/json',
    ], '{invalid json}');

    $this->assertResponseStatusCodeSame(400);
    $response = json_decode($client->getResponse()->getContent(), true);
    $this->assertArrayHasKey('error', $response);
    $this->assertStringContainsString('Invalid JSON', $response['error']);
}
```

### Validation Test Checklist
For every controller endpoint, test:
- ✅ Success case with valid data
- ✅ Missing required fields
- ✅ Invalid field types
- ✅ Invalid field values (negative numbers, empty strings, etc.)
- ✅ Invalid JSON format
- ✅ Empty arrays when minimum count required
- ✅ Verify error response structure (`errors` or `error` key)
- ✅ Verify specific error messages

## Test Utilities

### Test Doubles
- Use PHPUnit mocks for external dependencies
- Create in-memory implementations for repositories
- Use test fixtures for complex data setup

### Data Providers
```php
/**
 * @dataProvider invalidEmailProvider
 */
public function testShouldThrowExceptionForInvalidEmails(string $invalidEmail): void
{
    $this->expectException(\InvalidArgumentException::class);
    
    new Email($invalidEmail);
}

public static function invalidEmailProvider(): array
{
    return [
        ['invalid'],
        ['@example.com'],
        ['user@'],
        ['user@example'],
    ];
}
```

## Coverage Goals

- **Domain Layer**: 100% coverage (entities, value objects, domain services)
- **Application Layer**: 90%+ coverage
- **Infrastructure Layer**: 80%+ coverage
- **Presentation Layer**: 70%+ coverage

## Running Tests

### Using Makefile (Recommended)
```bash
# Run all tests
make test

# Run unit tests only
make test-unit

# Run feature tests only
make test-feature

# Run tests with coverage
make test-coverage

# Run tests with verbose output
make test-verbose

# Run specific test file
make test-file FILE=tests/Feature/Order/CreateOrderTest.php

# Run tests with filter
make test-filter FILTER=CreateOrderRequest
```

### Direct Docker Commands
```bash
# Run all tests (inside Docker container)
docker-compose exec -T php vendor/bin/phpunit tests/

# Run specific test suite
docker-compose exec -T php vendor/bin/phpunit tests/Unit
docker-compose exec -T php vendor/bin/phpunit tests/Feature

# Run specific test file
docker-compose exec -T php vendor/bin/phpunit tests/Feature/Order/CreateOrderTest.php

# Run with filter
docker-compose exec -T php vendor/bin/phpunit tests/ --filter CreateOrderRequest

# Run with coverage
docker-compose exec -T php vendor/bin/phpunit --coverage-html coverage/
```

### Test Execution Workflow
1. **After making code changes** → Run `make test`
2. **If tests fail** → Fix the issues immediately
3. **Re-run tests** → Verify all tests pass
4. **Only then** → Consider the work complete

## Testing Requirements

### Mandatory Tests for Controllers
1. **Unit tests for Request DTOs** - Test `createCommand()` methods
2. **Feature tests for all validation scenarios** - Test every validation constraint
3. **Feature tests for success cases** - Test happy path
4. **Feature tests for error responses** - Verify error structure and messages

### Test Coverage Requirements
- **Request DTOs**: 100% coverage (especially `createCommand()` methods)
- **Controllers**: 90%+ coverage via feature tests
- **Validation scenarios**: All constraints must be tested

### Test Execution Requirements
- **CRITICAL: Always run tests after code changes** - Use `make test` command
- **All tests MUST pass** - Fix any failures before considering work complete
- **Never commit code with failing tests** - Tests are a gate for code quality
- **Run tests before finalizing any implementation** - Catch issues early
