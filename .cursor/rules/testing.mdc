---
description: Unit and Feature Testing Guidelines
globs: ["tests/**/*.php"]
---

# Testing Guidelines

## Test Structure

### Directory Organization
Mirror `src/` structure in `tests/`:
```
tests/
├── Unit/
│   └── Domain/
│       └── {BoundedContext}/
│           ├── Entity/
│           ├── ValueObject/
│           └── Service/
├── Feature/
│   └── {BoundedContext}/
│       └── {UseCase}Test.php
└── Integration/
    └── Infrastructure/
```

## Test Types

### Unit Tests
- Test individual classes in isolation
- Focus on Domain layer (entities, value objects, domain services)
- Mock all external dependencies
- Fast execution
- High code coverage target

### Feature Tests
- Test complete use cases end-to-end
- Test Application layer (commands, queries, services)
- May use real implementations or test doubles
- Verify business logic flows

### Integration Tests
- Test Infrastructure layer
- Test interactions with external systems (database, APIs)
- Use test database or mocks for external services

## Testing Best Practices

### AAA Pattern
Follow Arrange, Act, Assert pattern:

```php
public function testShouldCreateValidEmail(): void
{
    // Arrange
    $emailValue = 'user@example.com';
    
    // Act
    $email = new Email($emailValue);
    
    // Assert
    $this->assertSame($emailValue, $email->getValue());
}
```

### Test Naming
- Use descriptive test method names
- Format: `testShould{ExpectedBehavior}When{Condition}()`
- Examples:
  - `testShouldThrowExceptionWhenEmailIsInvalid()`
  - `testShouldReturnUserWhenIdExists()`
  - `testShouldReturnNullWhenUserNotFound()`

### Test Organization
- One test class per class under test
- Group related tests using `@group` annotation
- Use data providers for testing multiple scenarios

## Unit Test Examples

### Value Object Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\User\ValueObject;

use App\Domain\User\ValueObject\Email;
use PHPUnit\Framework\TestCase;

final class EmailTest extends TestCase
{
    public function testShouldCreateValidEmail(): void
    {
        $email = new Email('user@example.com');
        
        $this->assertSame('user@example.com', $email->getValue());
    }

    public function testShouldThrowExceptionWhenEmailIsInvalid(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('Invalid email address');
        
        new Email('invalid-email');
    }

    public function testShouldReturnTrueWhenEmailsAreEqual(): void
    {
        $email1 = new Email('user@example.com');
        $email2 = new Email('user@example.com');
        
        $this->assertTrue($email1->equals($email2));
    }

    public function testShouldReturnFalseWhenEmailsAreDifferent(): void
    {
        $email1 = new Email('user1@example.com');
        $email2 = new Email('user2@example.com');
        
        $this->assertFalse($email1->equals($email2));
    }
}
```

### Entity Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\User\Entity;

use App\Domain\User\Entity\User;
use App\Domain\User\ValueObject\Email;
use App\Domain\User\ValueObject\UserId;
use PHPUnit\Framework\TestCase;

final class UserTest extends TestCase
{
    public function testShouldCreateUser(): void
    {
        $userId = UserId::generate();
        $email = new Email('user@example.com');
        $name = 'John Doe';
        
        $user = new User($userId, $email, $name);
        
        $this->assertSame($userId, $user->getId());
        $this->assertSame($email, $user->getEmail());
        $this->assertSame($name, $user->getName());
    }

    public function testShouldChangeName(): void
    {
        $user = $this->createUser();
        $newName = 'Jane Doe';
        
        $user->changeName($newName);
        
        $this->assertSame($newName, $user->getName());
    }

    private function createUser(): User
    {
        return new User(
            UserId::generate(),
            new Email('user@example.com'),
            'John Doe'
        );
    }
}
```

### Domain Service Test with Mocking
```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\User\Service;

use App\Domain\User\Entity\User;
use App\Domain\User\Repository\UserRepositoryInterface;
use App\Domain\User\Service\UserService;
use App\Domain\User\ValueObject\Email;
use App\Domain\User\ValueObject\UserId;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;

final class UserServiceTest extends TestCase
{
    private UserRepositoryInterface&MockObject $repository;
    private UserService $service;

    protected function setUp(): void
    {
        $this->repository = $this->createMock(UserRepositoryInterface::class);
        $this->service = new UserService($this->repository);
    }

    public function testShouldCreateUser(): void
    {
        $email = new Email('user@example.com');
        $name = 'John Doe';
        
        $this->repository
            ->expects($this->once())
            ->method('save')
            ->with($this->callback(function (User $user) use ($email, $name) {
                return $user->getEmail()->equals($email) 
                    && $user->getName() === $name;
            }));
        
        $user = $this->service->createUser($email, $name);
        
        $this->assertInstanceOf(User::class, $user);
    }
}
```

## Feature Test Examples

### Application Service Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Feature\User;

use App\Application\User\Command\CreateUserCommand;
use App\Application\User\Command\CreateUserHandler;
use App\Domain\User\Repository\UserRepositoryInterface;
use PHPUnit\Framework\TestCase;

final class CreateUserTest extends TestCase
{
    private UserRepositoryInterface $repository;
    private CreateUserHandler $handler;

    protected function setUp(): void
    {
        // Use real repository or in-memory implementation
        $this->repository = new InMemoryUserRepository();
        $this->handler = new CreateUserHandler($this->repository);
    }

    public function testShouldCreateUserSuccessfully(): void
    {
        $command = new CreateUserCommand(
            'user@example.com',
            'John Doe'
        );
        
        $user = $this->handler->handle($command);
        
        $this->assertNotNull($user);
        $this->assertSame('user@example.com', $user->getEmail()->getValue());
        $this->assertSame('John Doe', $user->getName());
        
        $savedUser = $this->repository->findById($user->getId());
        $this->assertNotNull($savedUser);
    }
}
```

### HTTP Endpoint Test
```php
<?php

declare(strict_types=1);

namespace App\Tests\Feature\User;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

final class CreateUserEndpointTest extends WebTestCase
{
    public function testShouldCreateUserViaApi(): void
    {
        $client = static::createClient();
        
        $client->request(
            'POST',
            '/api/users',
            [],
            [],
            ['CONTENT_TYPE' => 'application/json'],
            json_encode([
                'email' => 'user@example.com',
                'name' => 'John Doe',
            ])
        );
        
        $this->assertResponseStatusCodeSame(201);
        $this->assertJson($client->getResponse()->getContent());
        
        $response = json_decode($client->getResponse()->getContent(), true);
        $this->assertArrayHasKey('id', $response);
        $this->assertSame('user@example.com', $response['email']);
    }

    public function testShouldReturn400WhenEmailIsInvalid(): void
    {
        $client = static::createClient();
        
        $client->request(
            'POST',
            '/api/users',
            [],
            [],
            ['CONTENT_TYPE' => 'application/json'],
            json_encode([
                'email' => 'invalid-email',
                'name' => 'John Doe',
            ])
        );
        
        $this->assertResponseStatusCodeSame(400);
        $response = json_decode($client->getResponse()->getContent(), true);
        $this->assertArrayHasKey('errors', $response);
        $this->assertArrayHasKey('email', $response['errors']);
    }
}
```

## Request DTO Testing

### Unit Tests for Request DTOs
**CRITICAL**: Always create unit tests for request DTOs, especially for `createCommand()` methods.

```php
<?php

declare(strict_types=1);

namespace App\Tests\Unit\Presentation\Request;

use App\Application\Order\Command\CreateOrderCommand;
use App\Presentation\Request\CreateOrderRequest;
use PHPUnit\Framework\TestCase;

final class CreateOrderRequestTest extends TestCase
{
    public function testShouldCreateCommandFromRequest(): void
    {
        // Arrange
        $request = new CreateOrderRequest(
            sum: 1000,
            contractorType: 1,
            items: []
        );

        // Act
        $command = $request->createCommand();

        // Assert
        $this->assertInstanceOf(CreateOrderCommand::class, $command);
        $this->assertEquals(1000, $command->sum);
        $this->assertEquals(1, $command->contractorType);
    }
}
```

### Feature Tests for Validation
**CRITICAL**: Always test all validation scenarios in feature tests.

```php
public function testShouldReturnBadRequestWhenRequiredFieldsAreMissing(): void
{
    $client = static::createClient();
    $requestData = ['sum' => 1000]; // Missing required fields

    $client->request('POST', '/api/orders', [], [], [
        'CONTENT_TYPE' => 'application/json',
    ], json_encode($requestData));

    $this->assertResponseStatusCodeSame(400);
    $response = json_decode($client->getResponse()->getContent(), true);
    $this->assertArrayHasKey('errors', $response);
    $this->assertArrayHasKey('contractorType', $response['errors']);
}

public function testShouldReturnBadRequestWhenInvalidJsonFormat(): void
{
    $client = static::createClient();

    $client->request('POST', '/api/orders', [], [], [
        'CONTENT_TYPE' => 'application/json',
    ], '{invalid json}');

    $this->assertResponseStatusCodeSame(400);
    $response = json_decode($client->getResponse()->getContent(), true);
    $this->assertArrayHasKey('error', $response);
    $this->assertStringContainsString('Invalid JSON', $response['error']);
}
```

### Validation Test Checklist
For every controller endpoint, test:
- ✅ Success case with valid data
- ✅ Missing required fields
- ✅ Invalid field types
- ✅ Invalid field values (negative numbers, empty strings, etc.)
- ✅ Invalid JSON format
- ✅ Empty arrays when minimum count required
- ✅ Verify error response structure (`errors` or `error` key)
- ✅ Verify specific error messages

## Test Utilities

### Test Doubles
- Use PHPUnit mocks for external dependencies
- Create in-memory implementations for repositories
- Use test fixtures for complex data setup

### Data Providers
```php
/**
 * @dataProvider invalidEmailProvider
 */
public function testShouldThrowExceptionForInvalidEmails(string $invalidEmail): void
{
    $this->expectException(\InvalidArgumentException::class);
    
    new Email($invalidEmail);
}

public static function invalidEmailProvider(): array
{
    return [
        ['invalid'],
        ['@example.com'],
        ['user@'],
        ['user@example'],
    ];
}
```

## Coverage Goals

- **Domain Layer**: 100% coverage (entities, value objects, domain services)
- **Application Layer**: 90%+ coverage
- **Infrastructure Layer**: 80%+ coverage
- **Presentation Layer**: 70%+ coverage

## Running Tests

### Using Makefile (Recommended)
```bash
# Run all tests
make test

# Run tests with coverage
make test-coverage

# Run tests with verbose output
make test-verbose

# Run specific test file
make test-file FILE=tests/Feature/Order/CreateOrderTest.php

# Run tests with filter
make test-filter FILTER=CreateOrderRequest
```

### Direct Docker Commands
```bash
# Run all tests (inside Docker container)
docker-compose exec -T php vendor/bin/phpunit tests/

# Run specific test file
docker-compose exec -T php vendor/bin/phpunit tests/Feature/Order/CreateOrderTest.php

# Run with filter
docker-compose exec -T php vendor/bin/phpunit tests/ --filter CreateOrderRequest

# Run with coverage
docker-compose exec -T php vendor/bin/phpunit --coverage-html coverage/
```

### Test Execution Workflow
Follow the standard "Test Execution and Validation" workflow:
1. **Run PHPStan for src folder** → `make phpstan-src` and fix any issues
2. **Run CodeSniffer for src folder** → `make phpcbf-src` then `make phpcs-src` and fix any remaining issues
3. **Run deptrac** → `make deptrack` and fix any architectural violations
4. **Run all tests** → `make test` and fix any failing tests
5. **Run PHPStan globally** → `make phpstan` and fix any issues
6. **Run CodeSniffer globally** → `make phpcbf` then `make phpcs` and fix any remaining issues
7. **Run tests with coverage** → `make test-coverage` to generate coverage report
8. **Compare coverage with threshold** → `make test-coverage-check` to compare current coverage with `coverage_percent` file
9. **If coverage decreased** → `make test-coverage-analyze` to identify uncovered code, then create or update tests to restore coverage to at least the previous level
10. **Verify test coverage** → Ensure coverage is maintained or improved after code changes

## Testing Requirements

### Mandatory Tests for Controllers
1. **Unit tests for Request DTOs** - Test `createCommand()` methods
2. **Feature tests for all validation scenarios** - Test every validation constraint
3. **Feature tests for success cases** - Test happy path
4. **Feature tests for error responses** - Verify error structure and messages

### Test Coverage Requirements
- **Request DTOs**: 100% coverage (especially `createCommand()` methods)
- **Controllers**: 90%+ coverage via feature tests
- **Validation scenarios**: All constraints must be tested

### Test Execution Requirements
- **CRITICAL: Follow the standard Test Execution and Validation workflow** - See workflow above
- **All tests MUST pass** - Fix any failures before considering work complete
- **Never commit code with failing tests** - Tests are a gate for code quality
- **Run tests before finalizing any implementation** - Catch issues early
- **Use `make test` to run all tests** - Do not use separate unit/feature test commands

### SQL Query Quality Review
**MANDATORY**: All database queries must be reviewed for quality, performance, and readability.

#### SQL Quality Checklist
- [ ] **Query Readability**: SQL queries are well-formatted, properly indented, and easy to understand
- [ ] **Index Usage**: Queries use appropriate indexes (e.g., `created_at` for ordering, foreign keys for JOINs)
- [ ] **Performance**: Queries are optimized (single query with JOINs, no N+1 problems, efficient WHERE clauses)
- [ ] **Query Structure**: Uses appropriate SQL clauses (LIMIT, ORDER BY, JOIN) correctly
- [ ] **Data Volume Testing**: Query execution time tested with realistic data volumes
- [ ] **No Redundant Queries**: All needed data loaded in initial query rather than separate lookups

#### Common SQL Quality Issues to Avoid
- ❌ N+1 query problems (loading related data in loops)
- ❌ Missing indexes on frequently queried columns
- ❌ Loading unnecessary columns or data
- ❌ Inefficient JOINs or subqueries
- ❌ Missing LIMIT clauses on potentially large result sets
- ❌ Poor query formatting making code hard to read

#### SQL Quality Review Process
1. Review all SQL queries in repository implementations
2. Verify indexes exist for columns used in WHERE, ORDER BY, and JOIN clauses
3. Test query performance with realistic data volumes
4. Ensure queries are readable and well-formatted
5. Verify no N+1 query problems exist
6. Confirm all needed data is loaded efficiently

### Manual API Testing
**MANDATORY**: All API endpoints must be manually tested using curl or similar tools before considering work complete.

#### Manual Testing Requirements
- **MUST test all endpoints manually** - Use curl or HTTP client tools
- **MUST test success cases** - Verify correct response structure and data
- **MUST test validation errors** - Verify error responses for invalid inputs
- **MUST test edge cases** - Empty results, boundary values, etc.
- **MUST verify database state** - Confirm data is persisted correctly after API calls
- **MUST verify response matches OpenAPI documentation** - Ensure actual responses match documented schemas

#### Manual Testing Checklist
- [ ] Start application services (`make up` or `docker-compose up -d`)
- [ ] Test endpoint with valid data and verify success response
- [ ] Test endpoint with different valid parameter values
- [ ] Test endpoint without required parameters and verify validation error
- [ ] Test endpoint with invalid parameter values (negative, zero, non-integer, etc.)
- [ ] Test endpoint edge cases (empty results, boundary values)
- [ ] Verify response JSON structure matches OpenAPI documentation
- [ ] Verify database state after API calls (data persisted correctly)
- [ ] Test all HTTP methods and status codes for the endpoint

#### Example Manual Testing Commands
```bash
# Test GET endpoint with valid parameter
curl -X GET "http://localhost:8080/api/orders?limit=5" \
  -H "Accept: application/json"

# Test endpoint without required parameter
curl -X GET "http://localhost:8080/api/orders" \
  -H "Accept: application/json"

# Test endpoint with invalid parameter
curl -X GET "http://localhost:8080/api/orders?limit=-1" \
  -H "Accept: application/json"

# Test POST endpoint with valid data
curl -X POST "http://localhost:8080/api/orders" \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{"sum": 1000, "contractorType": 1, "items": [{"productId": 1, "price": 1000, "quantity": 1}]}'
```

#### Manual Testing in tasks.md
Every `tasks.md` file MUST include a "Manual API Testing" section with:
- Tasks to start application services
- curl commands for testing all endpoint scenarios
- Verification steps for responses and database state
- Testing of validation errors and edge cases
